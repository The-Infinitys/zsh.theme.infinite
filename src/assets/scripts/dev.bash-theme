#!/bin/bash

# --- 1. 右プロンプト (RPROMPT) の擬似再現について ---
# BashにはRPROMPTがないため、右側に情報を出すにはターミナルの
# 制御シーケンスを使う必要がありますが、入力行が崩れやすいため、
# ここではシンプルな左プロンプトのみに統合するのが一般的です。

# --- 2. Transient Prompt (確定後の書き換え) の実装 ---
# Bashには zle-line-finish がないため、trap を使って
# 「コマンドが実行される直前」を検知します。

_bash_infinite_preexec() {
    # コマンド確定時にプロンプトを「transient（シンプル）」なものに書き換える
    # $? は直前のコマンドの結果
    PS1="$(SHELL=bash {{RUN_DIR}}/zsh-infinite zsh prompt transient --exit-code $? 2>/dev/null)"
    
    # 書き換えたPS1を即座に描画させる（カーソル位置の調整）
    # ただし、Bashの標準機能ではこれ以上の制御が難しいため、
    # 物理的な表示が少し残る場合があります。
}

# DEBUG trap は各コマンドの実行直前に実行されます
trap '_bash_infinite_preexec' DEBUG

# --- 3. 通常時（入力中）のプロンプト構築 ---
# Zshの precmd に相当するのが PROMPT_COMMAND です。
_bash_infinite_prompt_command() {
    local exit_code=$?
    
    # Rust側で env::var("STATUS") を使う設計を維持
    # Bashの PS1 は動的評価するためにシングルクォートで囲むか、
    # 毎回 PS1 自体を直接書き換えます。
    
    # 左プロンプトの設定
    PS1="$(SHELL=bash STATUS=$exit_code {{RUN_DIR}}/zsh-infinite zsh prompt left 2>/dev/null)"
    
    # Bashで右プロンプトを無理やり出したい場合は、以下のようにRust側で
    # ターミナルの横幅を計算して空白を埋める文字列を出力させる必要があります。
}

# PROMPT_COMMAND を登録
PROMPT_COMMAND="_bash_infinite_prompt_command"